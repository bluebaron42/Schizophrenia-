name: Build and Deploy Module

on:
  push:
    tags:
      - 'v*'
  workflow_dispatch:

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
      
      - name: Install dependencies
        run: npm install
      
      - name: Fix JSX syntax issues
        run: |
          echo "ðŸ”§ Fixing JSX syntax in .tsx and .jsx files..."
          
          # Create the fix_jsx.py script inline
          cat > /tmp/fix_jsx.py << 'PYTHON_SCRIPT'
          #!/usr/bin/env python3
          import sys
          import re
          
          if len(sys.argv) < 2:
              print("Usage: fix_jsx.py <file>")
              sys.exit(1)
          
          filepath = sys.argv[1]
          
          with open(filepath, 'r', encoding='utf-8') as f:
              content = f.read()
          
          # Track fixes for reporting
          fixes_made = []
          
          # Fix HTML entities first
          original = content
          content = re.sub(r'&lt;', '{"<"}', content)
          content = re.sub(r'&gt;', '{">"}', content)
          content = re.sub(r'&amp;', '{"&"}', content)
          if content != original:
              fixes_made.append("HTML entities")
          
          # Fix > at start of line/text (terminal-style output)
          original = content
          content = re.sub(r'(\s+|^)>\s+([A-Z_])', r'\1{">"} \2', content, flags=re.MULTILINE)
          if content != original:
              fixes_made.append("Angle brackets at line start")
          
          # Fix >> at start of text
          original = content
          content = re.sub(r'(>)>>\s+', r'\1{">>"} ', content)
          if content != original:
              fixes_made.append("Double angle brackets")
          
          # COMPREHENSIVE arrow operator fix (->)
          original = content
          # Pattern 1: -> with spaces on both sides
          content = re.sub(r'(\s)->(\s)', r'\1 â†’ \2', content)
          # Pattern 2: -> at end of word/text
          content = re.sub(r'([a-zA-Z])->([a-zA-Z\s])', r'\1 â†’ \2', content)
          # Pattern 3: -> in quotes/strings within JSX
          content = re.sub(r'"([^"]*)->([^"]*)"', lambda m: f'"{m.group(1)} â†’ {m.group(2)}"', content)
          # Pattern 4: Catch any remaining -> in text content
          content = re.sub(r'([^=<>!])->([^=<>])', r'\1 â†’ \2', content)
          if content != original:
              fixes_made.append("Arrow operators (â†’)")
          
          # Fix comparison operators in various contexts
          original = content
          # In parentheses: (<18, >5, etc.)
          content = re.sub(r'\((<)(\d+)', r'({"<"}\2', content)
          content = re.sub(r'\((>)(\d+)', r'({">"}\2', content)
          # Standalone comparisons in text
          content = re.sub(r'(\s)>=(\s)', r'\1 â‰¥ \2', content)
          content = re.sub(r'(\s)<=(\s)', r'\1 â‰¤ \2', content)
          # Generic < and > in text (but not in JSX tags or code)
          content = re.sub(r'(\s)<(\s)(?![A-Za-z])', r'\1{"<"}\2', content)
          content = re.sub(r'(\s)>(\s)(?![A-Za-z])', r'\1{">"}\2', content)
          if content != original:
              fixes_made.append("Comparison operators")
          
          # Fix malformed escapes
          original = content
          # {"->"} followed by stray >
          content = re.sub(r'\{"->">\}', r' â†’ ', content)
          content = re.sub(r'\{"->"\}\s*>', r' â†’ ', content)
          # Multiple consecutive escapes
          content = re.sub(r'\{"->"}\s*\{"->"}\s*\{"->"}\s*\{"->"}\s*\{"->"}', r' â†’ â†’ â†’ â†’ ', content)
          content = re.sub(r'(\{"->"}\s*){2,}', lambda m: ' â†’ ' * m.group(0).count('{"->"}'), content)
          if content != original:
              fixes_made.append("Malformed escapes")
          
          # Final safety pass: catch any stray > or < in JSX text
          original = content
          # Find patterns like "text > text" or "text < text" in strings
          content = re.sub(r'([a-zA-Z])\s+>\s+([a-zA-Z])', r'\1 {">"} \2', content)
          content = re.sub(r'([a-zA-Z])\s+<\s+([a-zA-Z])', r'\1 {"<"} \2', content)
          if content != original:
              fixes_made.append("Stray angle brackets")
          
          with open(filepath, 'w', encoding='utf-8') as f:
              f.write(content)
          
          if fixes_made:
              print(f"âœ… Fixed: {', '.join(fixes_made)}")
          PYTHON_SCRIPT
          
          # Make it executable and run on all TSX/JSX files
          chmod +x /tmp/fix_jsx.py
          find . -name "*.tsx" -o -name "*.jsx" | while read file; do
            echo "  Checking: $file"
            python3 /tmp/fix_jsx.py "$file"
          done
          
          echo "âœ… JSX syntax check complete"
      
      - name: Build module
        run: npm run build
      
      - name: Create deployment package
        run: |
          cd dist
          zip -r ../module-dist.zip .
          cd ..
          echo "âœ… Created module-dist.zip ($(du -h module-dist.zip | cut -f1))"
      
      - name: Create GitHub Release
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          VERSION=${GITHUB_REF#refs/tags/}
          
          # Create release if triggered by tag
          if [[ $GITHUB_REF == refs/tags/* ]]; then
            gh release create "$VERSION" \
              module-dist.zip \
              --title "Release $VERSION" \
              --generate-notes
          else
            # For manual runs, create/update "latest" release
            gh release delete latest --yes 2>/dev/null || true
            gh release create latest \
              module-dist.zip \
              --title "Latest Build" \
              --notes "Latest development build" \
              --prerelease
          fi
      
      - name: Trigger Psych-hub sync
        env:
          DEPLOY_TOKEN: ${{ secrets.PSYCH_HUB_DEPLOY_TOKEN }}
        run: |
          if [[ $GITHUB_REF == refs/tags/* ]]; then
            VERSION=${GITHUB_REF#refs/tags/}
          else
            VERSION="latest"
          fi
          
          MODULE_NAME="${{ github.event.repository.name }}"
          
          # Extract display name from package.json or use repo name
          DISPLAY_NAME=$(node -p "try { require('./package.json').displayName } catch(e) { '$MODULE_NAME' }")
          
          echo "ðŸš€ Triggering Psych-hub sync for: $DISPLAY_NAME"
          
          curl -X POST \
            -H "Authorization: token $DEPLOY_TOKEN" \
            -H "Accept: application/vnd.github.v3+json" \
            https://api.github.com/repos/bluebaron42/Psych-hub/dispatches \
            -d "{
              \"event_type\": \"module_updated\",
              \"client_payload\": {
                \"module_repo\": \"$MODULE_NAME\",
                \"module_name\": \"$DISPLAY_NAME\",
                \"version\": \"$VERSION\"
              }
            }"
          
          echo "âœ… Sync triggered! Check: https://github.com/bluebaron42/Psych-hub/actions"
